//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by elmish-land.
//
//     Changes to this file may cause incorrect behavior and will be lost when
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

module ElmishLand.{{RootModule}}.App

open Elmish
open Elmish.HMR
open Feliz
open Feliz.Router
open ElmishLand
open {{RootModule}}
open {{RootModule}}.Shared

[<RequireQualifiedAccess>]
type PageModel =
    {{#each Routes}}
    | {{Name}} of {{ModuleName}}.Model
    {{/each}}
    | NotFound

[<RequireQualifiedAccess>]
type LayoutModel =
    {{#each Layouts}}
    | {{Name}} of {{ModuleName}}.Model
    {{/each}}
    | None

type Model = {
    Shared: SharedModel
    CurrentRoute: Route
    CurrentPage: PageModel
    CurrentLayout: LayoutModel
}

[<RequireQualifiedAccess>]
type PageMsg =
    {{#each Routes}}
    | {{MsgName}} of {{ModuleName}}.Msg
    {{/each}}

[<RequireQualifiedAccess>]
type LayoutMsg =
    {{#each Layouts}}
    | {{MsgName}} of {{ModuleName}}.Msg
    {{/each}}
    | NoOp

type Msg =
    | SharedMsg of SharedMsg
    | RouteChanged of Route
    | PageMsg of PageMsg
    | LayoutMsg of LayoutMsg

{{#each Layouts}}
let init{{Name}}Layout (currentLayout, sharedModel) =
    match currentLayout with
    | Some (LayoutModel.{{Name}} m) -> m, Command.none
    | _ ->
        let m, cmd = ({{ModuleName}}.layout sharedModel).Init ()
        m, Command.map (LayoutMsg.{{MsgName}} >> LayoutMsg) cmd
{{/each}}

let init () =
    let initialUrl = Route.parse (Router.currentUrl ())
    let sharedModel, sharedCmd = Shared.init ()

    let defaultModel = {
        Shared = sharedModel
        CurrentRoute = initialUrl
        CurrentPage = PageModel.NotFound
        CurrentLayout = LayoutModel.None
    }

    let initPage (page: Page<SharedMsg, 'model, 'msg>) pageModel layoutModel layoutCmd msg =
        let nextModel, nextCmd = page.Init()
        let nextPage = pageModel nextModel

        {
            defaultModel with
                CurrentPage = nextPage
                CurrentLayout = layoutModel
        },
        Command.batch [ sharedCmd; layoutCmd; Command.map msg nextCmd ] |> Command.toCmd SharedMsg

    match initialUrl with
    {{#each Routes}}
    | Route.{{Name}} route ->
        let layoutModel, layoutCmd = init{{LayoutName}}Layout (None, sharedModel)
        initPage ({{ModuleName}}.page sharedModel layoutModel route) PageModel.{{Name}} (LayoutModel.{{LayoutName}} layoutModel) layoutCmd (PageMsg.{{MsgName}} >> PageMsg)
    {{/each}}
    | Route.NotFound ->
        {
            defaultModel with
                CurrentPage = PageModel.NotFound
        },
        Cmd.none

let update (msg: Msg) (model: Model) =
    let updatePage (page: Page<SharedMsg, 'model, 'msg>) model' pageModel pageMsg msg =
        let model'', cmd = page.Update pageMsg model'

        {
            model with
                CurrentPage = pageModel model''
        },
        Command.map msg cmd |> Command.toCmd SharedMsg

    let updateLayout (layout: Layout<_,_,_>) model' layoutModel layoutMsg msg =
        let model'', cmd = layout.Update layoutMsg model'

        {
            model with
                CurrentLayout = layoutModel model''
        },
        Command.map msg cmd |> Command.toCmd SharedMsg

    match msg with
    | SharedMsg msg' ->
        let model'', cmd = Shared.update msg' model.Shared
        { model with Shared = model'' }, Command.map SharedMsg cmd |> Command.toCmd SharedMsg
    | RouteChanged nextRoute ->
        let changeRoute (page: Page<SharedMsg, 'model, 'msg>) pageModel layoutModel layoutCmd msg =
            let model', msg' = page.Init()
            {
                model with
                    CurrentPage = pageModel model'
                    CurrentRoute = nextRoute
                    CurrentLayout = layoutModel
            },
            Command.batch [ layoutCmd; Command.map msg msg' ] |> Command.toCmd SharedMsg
        match nextRoute with
        {{#each Routes}}
        | Route.{{Name}} route ->
            let layoutModel, layoutCmd = init{{LayoutName}}Layout (Some model.CurrentLayout, model.Shared)
            changeRoute ({{ModuleName}}.page model.Shared layoutModel route) PageModel.{{Name}} (LayoutModel.{{LayoutName}} layoutModel) layoutCmd (PageMsg.{{MsgName}} >> PageMsg)
        {{/each}}
        | Route.NotFound ->
            {
                model with
                    CurrentPage = PageModel.NotFound
                    CurrentRoute = Route.NotFound
                    CurrentLayout = LayoutModel.None
            },
            Cmd.none
    | PageMsg pageMsg ->
        {{#each Layouts}}
        let get{{Name}}Layout () =
            match model.CurrentLayout with
            | LayoutModel.{{Name}} m -> m
            | _ -> failwith "CurrentLayout is not set to {{Name}}Layout"
        {{/each}}

        match pageMsg, model.CurrentPage, model.CurrentRoute with
        {{#each Routes}}
        | PageMsg.{{MsgName}} msg', PageModel.{{Name}} model', Route.{{Name}} route ->
            updatePage ({{ModuleName}}.page model.Shared (get{{LayoutName}}Layout ()) route) model' PageModel.{{Name}} msg' (PageMsg.{{MsgName}} >> PageMsg)
        {{/each}}
        | msg', model', route' ->
            printfn $"Unhandled PageMsg, CurrentPage.Model and CurrentRoute. Got\nMsg:\n%A{msg'}\nCurrentPage.Model:\n%A{model'}\nCurrentRoute:\n%A{route'}'"
            model, Cmd.none
    | LayoutMsg layoutMsg ->
        match layoutMsg, model.CurrentLayout with
        {{#each Layouts}}
        | LayoutMsg.{{MsgName}} msg', LayoutModel.{{Name}} model' ->
            updateLayout ({{ModuleName}}.layout model.Shared) model' LayoutModel.{{Name}} msg' (LayoutMsg.{{MsgName}} >> LayoutMsg)
        {{/each}}
        | msg', model' ->
            printfn $"Unhandled LayoutMsg, CurrentLayout.Model. Got\nMsg:\n%A{msg'}\nCurrentLayout.Model:\n%A{model'}"
            model, Cmd.none

let inline (|Renderable|) (o: 'x when 'x: (member Render: unit -> ReactElement)) = o

let view (model: Model) (dispatch: Msg -> unit) =
    let currentPageView =
        match model.CurrentPage, model.CurrentRoute, model.CurrentLayout with
        {{#each Routes}}
        | PageModel.{{Name}} m, Route.{{Name}} route, LayoutModel.{{LayoutName}} layoutModel ->
            ({{ModuleName}}.page model.Shared layoutModel route).View m (PageMsg.{{MsgName}} >> PageMsg >> dispatch)
        {{/each}}
        | _ -> failwith "Page not found"

    let currentView =
        match model.CurrentLayout with
        {{#each Layouts}}
        | LayoutModel.{{Name}} m ->
            ({{ModuleName}}.layout model.Shared).View m currentPageView (LayoutMsg.{{MsgName}} >> LayoutMsg >> dispatch)
        {{/each}}
        | LayoutModel.None -> currentPageView

    let currentReactElement =
        {{#if ViewTypeIsReact}}
        currentView
        {{else}}
        match currentView with
        | Renderable x -> x.Render()
        {{/if}}

    React.router [
        router.onUrlChanged (Route.parse >> RouteChanged >> dispatch)
        router.children [ currentReactElement ]
    ]

let subscribe model =
    Sub.batch [
        match model.CurrentLayout with
        {{#each Layouts}}
        | LayoutModel.{{Name}} m -> Sub.map "Layout{{Name}}" (LayoutMsg.{{MsgName}} >> LayoutMsg) (({{ModuleName}}.layout model.Shared).Subscriptions m)
        {{/each}}
        | _ -> Sub.none
        match model.CurrentPage, model.CurrentRoute, model.CurrentLayout with
        {{#each Routes}}
        | PageModel.{{Name}} m, Route.{{Name}} route, LayoutModel.{{LayoutName}} layoutModel ->
            Sub.map "Page{{Name}}" (PageMsg.{{MsgName}} >> PageMsg) (({{ModuleName}}.page model.Shared layoutModel route).Subscriptions m)
        {{/each}}
        | _ -> Sub.none
    ]

Program.mkProgram init update view
|> Program.withErrorHandler (fun (msg, ex) -> printfn "Program error handler:\r\n%s\r\n%O" msg ex)
|> Program.withReactBatched "app"
|> Program.withSubscription subscribe
|> Program.run
