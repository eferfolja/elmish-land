{{Disclaimer}}
module {{RootModule}}.App

open Elmish
open Elmish.React
open Elmish.HMR
open Feliz
open Feliz.Router
open {{RootModule}}.Routes
open {{RootModule}}.Pages

[<RequireQualifiedAccess>]
type Page =
    {{#each Routes}}
    | {{Name}} of {{ModuleName}}.Model
    {{/each}}
    | NotFound

type Model = {
    Shared: Shared.Model
    CurrentRoute: Route
    CurrentPage: Page
}

type Msg =
| SharedMsg of Shared.Msg
| RouteChanged of Route
{{#each Routes}}
| {{Name}}Msg of {{ModuleName}}.Msg
{{/each}}

let init () =
    let initialUrl = Route.parse (Router.currentUrl ())
    let sharedModel, sharedCmd = Shared.init ()

    let defaultModel = {
        Shared = sharedModel
        CurrentRoute = initialUrl
        CurrentPage = Page.NotFound
    }

    let initPage init initArgs page msg =
        let nextModel, nextCmd = init initArgs
        let nextPage = page nextModel

        {
            defaultModel with
                CurrentPage = nextPage
        },
        Cmd.batch [ sharedCmd; Cmd.map msg nextCmd ]

    match initialUrl with
    {{#each Routes}}
    | Route.{{Name}} {{#if ArgsPattern}}{{ArgsPattern}}{{/if}}->
        initPage {{ModuleName}}.init ({{ArgsUsage}}) Page.{{Name}} {{Name}}Msg
    {{/each}}
    | Route.NotFound ->
        {
            defaultModel with
                CurrentPage = Page.NotFound
        },
        Cmd.none

let update (msg: Msg) (model: Model) =
    let updatePage update msg' model' page msg =
        let model'', cmd = update msg' model'

        {
            model with
                CurrentPage = page model''
        },
        Cmd.map msg cmd
    match msg, model.CurrentPage with
    | SharedMsg msg', _ ->
        let model'', cmd = Shared.update msg' model.Shared
        { model with Shared = model'' }, Cmd.map SharedMsg cmd
    | RouteChanged nextRoute, _ ->
        let changeRoute init initArgs page msg =
            let model', msg' = init initArgs
            {
                model with
                    CurrentPage = page model'
                    CurrentRoute = nextRoute
            },
            Cmd.map msg msg'
        match nextRoute with
        {{#each Routes}}
        | Route.{{Name}} {{#if ArgsDefinition}}({{ArgsDefinition}}){{/if}} ->
            changeRoute {{ModuleName}}.init ({{#if ArgsUsage}}({{ArgsUsage}}){{/if}}) Page.{{Name}} {{Name}}Msg
        {{/each}}
        | Route.NotFound ->
            {
                model with
                    CurrentPage = Page.NotFound
                    CurrentRoute = Route.NotFound
            },
            Cmd.none
    {{#each Routes}}
    | {{Name}}Msg msg', Page.{{Name}} model' ->
        updatePage {{ModuleName}}.update msg' model' Page.{{Name}} {{Name}}Msg
    {{/each}}
    | msg', model' ->
        printfn $"Unhandled App.Msg and CurrentPage.Model. Got\nMsg:\n%A{msg'}\nCurrentPage.Model:\n%A{model'}"
        model, Cmd.none

let view (model: Model) (dispatch: Msg -> unit) =
    let currentPageView =
        match model.CurrentPage with
        {{#each Routes}}
        | Page.{{Name}} m -> {{ModuleName}}.view m ({{Name}}Msg >> dispatch)
        {{/each}}
        | Page.NotFound -> Html.h1 "Sidan kunde inte hittas"

    React.router [
        router.onUrlChanged (Route.parse >> RouteChanged >> dispatch)
        router.children [ currentPageView ]
    ]

let subscribe model =
    Sub.batch [
        Sub.map "Shared_App" SharedMsg [ Shared.subscribeShared id ]
        match model.CurrentPage with
        {{#each Routes}}
        | Page.{{Name}} m -> Sub.map "{{Name}}" {{Name}}Msg ({{ModuleName}}.subscribe m)
        {{/each}}
        | Page.NotFound -> Sub.none
    ]

Program.mkProgram init update view
|> Program.withErrorHandler (fun (msg, ex) -> printfn "Program error handler:\r\n%s\r\n%O" msg ex)
|> Program.withReactBatched "app"
|> Program.withSubscription subscribe
|> Program.run
